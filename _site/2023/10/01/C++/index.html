<!DOCTYPE html>
<html lang="en"><!--
 __  __                __                                     __
/\ \/\ \              /\ \             __                    /\ \
\ \ \_\ \   __  __    \_\ \      __   /\_\      __       ___ \ \ \/'\
 \ \  _  \ /\ \/\ \   /'_` \   /'__`\ \/\ \   /'__`\    /'___\\ \ , <
  \ \ \ \ \\ \ \_\ \ /\ \L\ \ /\  __/  \ \ \ /\ \L\.\_ /\ \__/ \ \ \\`\
   \ \_\ \_\\/`____ \\ \___,_\\ \____\ _\ \ \\ \__/.\_\\ \____\ \ \_\ \_\
    \/_/\/_/ `/___/> \\/__,_ / \/____//\ \_\ \\/__/\/_/ \/____/  \/_/\/_/
                /\___/                \ \____/
                \/__/                  \/___/

Powered by Hydejack v7.2.0 <https://qwtel.com/hydejack/>
-->











<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">


  
<!-- Begin Jekyll SEO tag v2.3.0 -->
<title>C++ Understanding | blog</title>
<meta property="og:title" content="C++ Understanding" />
<meta name="author" content="<firstname> <lastname>" />
<meta property="og:locale" content="en" />
<meta name="description" content="Understanding on important concepts from C++ template programming, and sections in effective C++." />
<meta property="og:description" content="Understanding on important concepts from C++ template programming, and sections in effective C++." />
<link rel="canonical" href="http://localhost:4000/myBlog/2023/10/01/C++/" />
<meta property="og:url" content="http://localhost:4000/myBlog/2023/10/01/C++/" />
<meta property="og:site_name" content="blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-10-01T00:00:00-04:00" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/myBlog/2023/10/01/C++/"},"author":{"@type":"Person","name":"<firstname> <lastname>"},"@type":"BlogPosting","description":"Understanding on important concepts from C++ template programming, and sections in effective C++.","url":"http://localhost:4000/myBlog/2023/10/01/C++/","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/myBlog/assets/icons/icon.png"},"name":"<firstname> <lastname>"},"headline":"C++ Understanding","dateModified":"2023-10-01T00:00:00-04:00","datePublished":"2023-10-01T00:00:00-04:00","sameAs":null,"image":null,"name":null,"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  

  
    <meta name="keywords" content="">
  


<meta name="mobile-web-app-capable" content="yes">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="blog">
<meta name="apple-mobile-web-app-status-bar-style" content="black">

<meta name="application-name" content="blog">
<meta name="msapplication-config" content="/myBlog/assets/ieconfig.xml">


<meta name="theme-color" content="#4fb1ba">


<meta name="generator" content="Hydejack v7.2.0" />


<link rel="alternate" type="application/atom+xml" title="blog Feed" href="http://localhost:4000/myBlog/feed.xml">


<link rel="alternate" href="http://localhost:4000/myBlog/2023/10/01/C++/" hreflang="en">

<link rel="shortcut icon" href="/myBlog/assets/icons/favicon.ico">
<link rel="apple-touch-icon" href="/myBlog/assets/icons/icon.png">

<link rel="manifest" href="/myBlog/assets/manifest.json">


  <link rel="dns-prefetch" href="https://fonts.googleapis.com">
  <link rel="dns-prefetch" href="https://fonts.gstatic.com">




<link id="_katexJS"  rel="dns-prefetch" href="/myBlog/assets/bower_components/katex/dist/katex.min.js">
<link id="_katexCSS" rel="dns-prefetch" href="/myBlog/assets/bower_components/katex/dist/katex.min.css">

<script>
  function stdOnEnd(n,e){n.onload=function(){this.onerror=this.onload=null,e(null,n)},n.onerror=function(){this.onerror=this.onload=null,e(new Error("Failed to load "+this.src),n)}}function ieOnEnd(n,e){n.onreadystatechange=function(){"complete"!=this.readyState&&"loaded"!=this.readyState||(this.onreadystatechange=null,e(null,n))}}window.setRelStylesheet=function(n){function e(){this.rel="stylesheet"}var o=document.getElementById(n);o.addEventListener?o.addEventListener("load",e,!1):o.onload=e},window._loaded=!1,window.loadJSDeferred=function(n,e){function o(){window._loaded=!0;var o=document.createElement("script");o.src=n,e&&(("onload"in o?stdOnEnd:ieOnEnd)(o,e),o.onload||stdOnEnd(o,e));var t=document.scripts[0];t.parentNode.insertBefore(o,t)}window._loaded?o():window.addEventListener?window.addEventListener("load",o,!1):window.onload=o};
!function(a){"use strict";var b=function(b,c,d){function e(a){return h.body?a():void setTimeout(function(){e(a)})}function f(){i.addEventListener&&i.removeEventListener("load",f),i.media=d||"all"}var g,h=a.document,i=h.createElement("link");if(c)g=c;else{var j=(h.body||h.getElementsByTagName("head")[0]).childNodes;g=j[j.length-1]}var k=h.styleSheets;i.rel="stylesheet",i.href=b,i.media="only x",e(function(){g.parentNode.insertBefore(i,c?g:g.nextSibling)});var l=function(a){for(var b=i.href,c=k.length;c--;)if(k[c].href===b)return a();setTimeout(function(){l(a)})};return i.addEventListener&&i.addEventListener("load",f),i.onloadcssdefined=l,l(f),i};"undefined"!=typeof exports?exports.loadCSS=b:a.loadCSS=b}("undefined"!=typeof global?global:this);
!function(a){if(a.loadCSS){var b=loadCSS.relpreload={};if(b.support=function(){try{return a.document.createElement("link").relList.supports("preload")}catch(b){return!1}},b.poly=function(){for(var b=a.document.getElementsByTagName("link"),c=0;c<b.length;c++){var d=b[c];"preload"===d.rel&&"style"===d.getAttribute("as")&&(a.loadCSS(d.href,d,d.getAttribute("media")),d.rel=null)}},!b.support()){b.poly();var c=a.setInterval(b.poly,300);a.addEventListener&&a.addEventListener("load",function(){b.poly(),a.clearInterval(c)}),a.attachEvent&&a.attachEvent("onload",function(){a.clearInterval(c)})}}}(this);

  window._noPushState = false;
  window._noDrawer = false;
</script>

<!--[if gt IE 8]><!---->


<script>
  WebFontConfig = {
    
    google: {
      families: ['Roboto+Slab:700','Noto+Sans:400,400i,700,700i']
    },
    

    custom: {
      families: ['icomoon'],
      urls: ['/myBlog/assets/icomoon/style.css']
    }
  };
  (function(d) {
    var wf = d.createElement('script'), s = d.scripts[0];
    wf.src = "/myBlog/assets/bower_components/webfontloader/webfontloader.js";
    s.parentNode.insertBefore(wf, s);
  }(document));
</script>
<!--<![endif]-->

<noscript>
  
  

  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab:700%7CNoto+Sans:400,400i,700,700i">
    <style>
      html { font-family: 'Noto Sans', Helvetica, Arial, sans-serif }
      h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6, .heading { font-family: 'Roboto Slab', Helvetica, Arial, sans-serif }
    </style>
  

  <link rel="stylesheet" href="/myBlog/assets/icomoon/style.css">
</noscript>

<!--[if gt IE 8]><!---->



  <link rel="stylesheet" href="/myBlog/assets/css/hydejack-7.2.0.css">



<style id="_pageStyle">

.content a:not(.btn){color:#4fb1ba;border-color:rgba(79,177,186,0.2)}.content a:not(.btn):hover{border-color:#4fb1ba}:focus{outline-color:#4fb1ba}.btn-primary{color:#fff;background-color:#4fb1ba;border-color:#4fb1ba}.btn-primary:focus,.btn-primary.focus{box-shadow:0 0 0 3px rgba(79,177,186,0.5)}.btn-primary:hover,.btn-primary.hover{color:#fff;background-color:#409ba3;border-color:#409ba3}.btn-primary:disabled,.btn-primary.disabled{color:#fff;background-color:#4fb1ba;border-color:#4fb1ba}.btn-primary:active,.btn-primary.active{color:#fff;background-color:#409ba3;border-color:#409ba3}::selection{color:#fff;background:#4fb1ba}::-moz-selection{color:#fff;background:#4fb1ba}

</style>

<!--<![endif]-->




</head>

<body>
  <div class="navbar fixed-top">
  <div class="content">
    <div class="nav-btn-bar">
      <span class="sr-only">Jump to:</span>
      <a id="_menu" class="nav-btn no-hover" href="#_navigation">
        <span class="sr-only">Navigation</span>
        <span class="icon-menu"></span>
      </a>
    </div>
  </div>
</div>


<hy-push-state>
  <main
    id="_main"
    class="content fade-in layout-post"
    role="main"
    data-color="#4fb1ba"
    
      data-image="/myBlog/assets/img/sidebar-bg.jpg
"
      data-overlay
    
    >
    


<article id="post-2023-10-01-C++" class="page post" role="article">
  <header>
    <h1 class="post-title">
      
        C++ Understanding
      
    </h1>

    <p class="post-date heading">
      
      <time datetime="2023-10-01T00:00:00-04:00">01 Oct 2023</time>
      
      
      
      
      











      









on <a href="/myBlog/tag/hydejack/" class="flip-title">Hydejack</a>

    </p>

    



  
    <p class="message" >
      Understanding on important concepts from C++ template programming, and sections in effective C++.

    </p>
  


  </header>

  
    <p><a href="http://ultra.sdk.free.fr/docs/DxO/C%2B%2B%20Templates%20The%20Complete%20Guide.pdf">C++ template complete guide</a></p>

<p>template template parameters:
The name of a template parameter of a template template parameter can be used only in the declaration of other
parameters of that template template parameter. The following contrived template illustrates this concept:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">Buf</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Lexer</span> <span class="p">{</span>
 <span class="k">static</span> <span class="kt">char</span> <span class="n">storage</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
 <span class="n">Buf</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Lexer</span><span class="o">&lt;</span><span class="n">Buf</span><span class="o">&gt;::</span><span class="n">storage</span><span class="o">&gt;</span> <span class="n">buf</span><span class="p">;</span>
 <span class="err">…</span>
<span class="p">};</span> <span class="c1">// OK</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">List</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Node</span> <span class="p">{</span>
 <span class="k">static</span> <span class="n">T</span><span class="o">*</span> <span class="n">storage</span><span class="p">;</span> <span class="c1">// ERROR: a parameter of a template template</span>
 <span class="c1">// parameter cannot be used here</span>
 <span class="err">…</span>
<span class="p">};</span>
</code></pre></div></div>

<p>CMake <a href="https://cmake.org/cmake/help/latest/guide/tutorial/A%20Basic%20Starting%20Point.html#solution">tutorial</a></p>

<p>C++ friend <a href="https://blog.csdn.net/weixin_38293850/article/details/80191242">tutorial</a></p>

<p>qualified vs unqualified:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span> <span class="c1">// (1)</span>
<span class="kt">int</span> <span class="nf">lookup_example</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">)</span> <span class="c1">// (2)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// (3)</span>
    <span class="n">lookup_example</span><span class="p">(</span><span class="n">count</span><span class="p">);</span> <span class="c1">// unqualified count refers to (3)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">count</span> <span class="o">+</span> <span class="o">::</span><span class="n">count</span><span class="p">;</span> <span class="c1">// the first (unqualified) count refers to (2);</span>
<span class="p">}</span> <span class="c1">// the second (qualified) count refers to (1)</span>
</code></pre></div></div>

<p>How to find the pos of an elem in a vector:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span> <span class="o">-</span> <span class="n">begin</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</code></pre></div></div>

<h1 id="effective-c">Effective C++</h1>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">ptr</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span>
</code></pre></div></div>

<p>First const: what <code class="language-plaintext highlighter-rouge">ptr</code> points to is const.
Second const: ptr can’t be made to point to a different location, so <code class="language-plaintext highlighter-rouge">ptr</code> is const.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// return size of an array as a compile-time constant. (The</span>
<span class="c1">// array parameter has no name, because we care only about</span>
<span class="c1">// the number of elements it contains.)</span>
<span class="c1">//</span>
<span class="c1">// constexpr makes its result available during compilation.</span>
<span class="c1">// noexcept help compiler generate better code.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">arraySize</span><span class="p">(</span><span class="n">T</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span> <span class="k">noexcept</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">N</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="item-2-understand-auto-type-deduction">Item 2: UNderstand <code class="language-plaintext highlighter-rouge">auto</code> type deduction</h2>

<h3 id="tldr">TLDR</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">auto</code> type deduction is usually the same as template type deduction, but <code class="language-plaintext highlighter-rouge">auto</code> type deduction assumes that a braced initializer represents a <code class="language-plaintext highlighter-rouge">std::initializer_list</code>, and template type deduction doesn’t.</li>
  <li><code class="language-plaintext highlighter-rouge">auto</code> in a function return type or a lambda parameter implies template type deduction, not <code class="language-plaintext highlighter-rouge">auto</code> type deduction.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">auto</code> type deduction works like template type deduction.</p>

<p>array and function names decay into ptrs for non-ref type specifiers.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"R. N. Briggs"</span><span class="p">;</span><span class="c1">// name's type is const char[13]</span>
<span class="k">auto</span> <span class="n">arr1</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span><span class="c1">// arr1's type is const char*</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="n">arr2</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span><span class="c1">// arr2's type is const char (&amp;)[13]</span>

<span class="kt">void</span> <span class="nf">someFunc</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span><span class="c1">// someFunc is a function; type is void(int, double)</span>
<span class="k">auto</span> <span class="n">func1</span> <span class="o">=</span> <span class="n">someFunc</span><span class="p">;</span><span class="c1">// func1's type is void (*)(int, double)</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="n">func2</span> <span class="o">=</span> <span class="n">someFunc</span><span class="p">;</span><span class="c1">// func2's type is void (&amp;)(int, double)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">auto</code> may differ from template:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span><span class="c1">// type is int, value is 27</span>
<span class="k">auto</span> <span class="nf">x2</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span><span class="c1">// ditto</span>
<span class="k">auto</span> <span class="n">x3</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">27</span> <span class="p">};</span><span class="c1">// type is std::initializer_list&lt;int&gt;, value is { 27 }</span>
<span class="k">auto</span> <span class="n">x4</span><span class="p">{</span> <span class="mi">27</span> <span class="p">};</span><span class="c1">// ditto</span>
</code></pre></div></div>

<p>When an auto–declared variable is initialized with a
braced initializer, the deduced type is an instantiation of <code class="language-plaintext highlighter-rouge">std::initializer_list</code>.</p>

<p>a function with an <code class="language-plaintext highlighter-rouge">auto</code> return type that returns a braced initializer won’t compile(these uses of
<code class="language-plaintext highlighter-rouge">auto</code> employ template type deduction):</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="nf">createInitList</span><span class="p">()</span>
<span class="p">{</span>
<span class="k">return</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>
<span class="p">}</span>
<span class="c1">// error: can't deduce type</span>
<span class="c1">// for { 1, 2, 3 }</span>
</code></pre></div></div>

<h2 id="item-3-understand-decltype">Item 3: Understand decltype</h2>

<h3 id="tldr-1">TLDR</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">decltype</code> almost always yields the type of a variable or expression without any modifications.</li>
  <li>For lvalue expressions of type <code class="language-plaintext highlighter-rouge">T</code> other than names, decltype always reports a type of <code class="language-plaintext highlighter-rouge">T&amp;</code>`.</li>
  <li>C++14 supports <code class="language-plaintext highlighter-rouge">decltype(auto)</code>, which, like <code class="language-plaintext highlighter-rouge">auto</code>, deduces a type from its initializer, but it performs the type deduction using the <code class="language-plaintext highlighter-rouge">decltype</code> rules.</li>
</ul>

<p>A trailing return type has the advantage that the function’s params can be used in the specification of the return type.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Index</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">ABC</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">f1</span><span class="p">()</span>
<span class="p">{</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="err">…</span>
<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="c1">// decltype(x) is int, so f1 returns int</span>
<span class="p">}</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">f2</span><span class="p">()</span>
<span class="p">{</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="err">…</span>
<span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="c1">// decltype((x)) is int&amp;, so f2 returns int&amp;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="item-6-use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types">Item 6: Use the explicitly typed initializer idiom when auto deduces undesired types</h2>

<h4 id="tldr-2">TLDR</h4>

<ol>
  <li>“Invisible” proxy types can cause <code class="language-plaintext highlighter-rouge">auto</code> to deduce the “wrong” type for an initializing expression.</li>
  <li>The explicitly typed initializer idiom forces <code class="language-plaintext highlighter-rouge">auto</code> to deduce the type you want it to have.</li>
</ol>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">v</span> <span class="o">=</span> <span class="n">f</span><span class="p">()[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// v is not bool type</span>
<span class="n">f2</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// undefined behavior!</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">v</code> has a type of <code class="language-plaintext highlighter-rouge">std::vector&lt;bool&gt;::reference</code>, because:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">operator[]</code> for <code class="language-plaintext highlighter-rouge">std::vector&lt;T&gt;</code> is supposed to return a <code class="language-plaintext highlighter-rouge">T&amp;</code>.</li>
  <li>C++ forbids references for bits.</li>
  <li>The <code class="language-plaintext highlighter-rouge">std::vector&lt;bool&gt;::reference</code> it returns contains a pointer to a word in the data structure holding the bits, and it’s managed by a temporary <code class="language-plaintext highlighter-rouge">std::vector&lt;bool&gt;</code> object. At the end, the temp object is destroyed, and <code class="language-plaintext highlighter-rouge">v</code> contains a dangling pointer.</li>
</ol>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">v</span> <span class="o">=</span> <span class="n">f</span><span class="p">()[</span><span class="mi">1</span><span class="p">];</span>
</code></pre></div></div>

<p>Here <code class="language-plaintext highlighter-rouge">std::vector&lt;bool&gt;::reference</code> is implicitly converted to <code class="language-plaintext highlighter-rouge">bool</code>.
<code class="language-plaintext highlighter-rouge">std::vector&lt;bool&gt;::reference</code> is a <i>proxy class</i>. Smart pointer is also a proxy class.</p>

<p>Avoid <code class="language-plaintext highlighter-rouge">auto v = expression of "invisible" proxy class type;</code></p>

<h4 id="explicitly-typed-initializer-idiom">explicitly typed initializer idiom</h4>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">v</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">()[</span><span class="mi">1</span><span class="p">]);</span>
</code></pre></div></div>

<p>This can also be useful to emphasize that you’re deliberately creating a variable of a type that’s different from the one generated by the initializing expression, which makes things transparent.</p>

<h2 id="item-7-distinguish-between--and--when-creating-objects">Item 7: Distinguish between () and {} when creating objects</h2>

<h4 id="tldr-3">TLDR</h4>

<ol>
  <li>Braced initialization is the most widely usable initialization syntax, it prevents narrowing conversions, and it’s immune to C++’s most vexing parse.</li>
  <li>During constructor overload resolution, braced initializers are matched to <code class="language-plaintext highlighter-rouge">std::initializer_list</code> parameters if at all possible, even if other constructors offer seemingly better matches.</li>
  <li>An example of where the choice between parentheses and braces can make a significant difference is creating a <code class="language-plaintext highlighter-rouge">std::vector&lt;numeric type&gt;</code> with two arguments.</li>
  <li>Choosing between parentheses and braces for object creation inside templates can be challenging.</li>
</ol>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Widget</span> <span class="n">w1</span><span class="p">;</span> <span class="c1">// call default constructor</span>
<span class="n">Widget</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">w1</span><span class="p">;</span> <span class="c1">// not an assignmentl; calls copy ctor</span>
<span class="n">w1</span> <span class="o">=</span> <span class="n">w2</span><span class="p">;</span> <span class="c1">// an assignment; calls copy operator=</span>
</code></pre></div></div>

<p>C++11 introduces <em>uniform initialization</em>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span> <span class="c1">// v's initial content is 1,3,5</span>
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">;</span>
<span class="p">...</span>
<span class="kt">int</span> <span class="n">sum1</span><span class="p">{</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">+</span><span class="n">z</span><span class="p">};</span> <span class="c1">//err, sum of doubles may not be expressible as int</span>
</code></pre></div></div>

<p>Cons:</p>

<ul>
  <li>Confusion with <code class="language-plaintext highlighter-rouge">std::initializer_list</code>. Class’s ctor with <code class="language-plaintext highlighter-rouge">std::initializer_list</code> as param is always used if invoked by <code class="language-plaintext highlighter-rouge">Class{...}</code>, even if it might be a worse match comparing with other ctors.</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
<span class="nl">public:</span>
<span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">b</span><span class="p">);</span>
<span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">);</span>

<span class="n">Widget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span>
<span class="p">};</span>
<span class="n">Widget</span> <span class="n">w</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">};</span> <span class="c1">// error! requires narrowing conversions</span>
</code></pre></div></div>

<p>Templ implications:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="c1">// type of object to create</span>
        <span class="k">typename</span><span class="o">...</span> <span class="nc">Ts</span><span class="p">&gt;</span> <span class="c1">// types of arguments to use</span>
<span class="kt">void</span> <span class="nf">doSomeWork</span><span class="p">(</span><span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">create</span> <span class="n">local</span> <span class="n">T</span> <span class="n">object</span> <span class="n">from</span> <span class="n">params</span><span class="p">...</span>
  <span class="err">…</span>
<span class="p">}</span>
</code></pre></div></div>

<p>There are two ways to turn the line of pseudocode into real code:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">T</span> <span class="nf">localObject</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...);</span><span class="c1">// using parens</span>
<span class="n">T</span> <span class="n">localObject</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...};</span><span class="c1">// using braces</span>
</code></pre></div></div>

<p>Caller’s code:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="err">…</span>
<span class="n">doSomeWork</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</code></pre></div></div>

<p>If doSomeWork uses parentheses when creating localObject, the result is a
std::vector with 10 elements. If doSomeWork uses braces, the result is a std::vec
tor with 2 elements. Which is correct? The author of doSomeWork can’t know. Only
the caller can.</p>

<h2 id="item-8-prefer-nullptr-to-0-and-null">Item 8: prefer nullptr to 0 and NULL</h2>

<h4 id="tldr-4">TLDR</h4>

<ul>
  <li>Prefer <code class="language-plaintext highlighter-rouge">nullptr</code> to 0 and NULL.</li>
  <li>Avoid overloading on integral and pointer types.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">nullptr</code>’s type is <code class="language-plaintext highlighter-rouge">std::nullptr_t</code>, which implicitly converts to all raw pointer types.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span> <span class="c1">// calls f(void*) overload</span>
</code></pre></div></div>

<h2 id="item-9-prefer-alias-declarations-to-typedefs">Item 9: Prefer alias declarations to typedefs</h2>

<h4 id="tldr-5">TLDR</h4>

<ul>
  <li>alias declarations maybe templatized while <code class="language-plaintext highlighter-rouge">typedef</code>s cannot.</li>
  <li>Alias templates avoid the “::type” suffix and, in templates, the “typename” prefix often required to refer to typedefs.</li>
</ul>

<h2 id="item-10-prefer-scoped-enums-to-unscoped-enums">Item 10: Prefer scoped enums to unscoped enums</h2>

<h4 id="tldr-6">TLDR</h4>

<ul>
  <li>C++98-style enums are now known as unscoped enums.</li>
  <li>Enumerators of scoped enums are visible only within the enum. They convert to other types only with a cast.</li>
  <li>Both scoped and unscoped enums support specification of the underlying type. The default underlying type for scoped enums is int. Unscoped enums have no default underlying type.</li>
  <li>Scoped enums may always be forward-declared. Unscoped enums may be forward-declared only if their declaration specifies an underlying type.</li>
</ul>

<p>Scoped enums:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">Color</span> <span class="p">{</span> <span class="n">black</span><span class="p">,</span> <span class="n">white</span><span class="p">,</span> <span class="n">red</span> <span class="p">};</span> <span class="c1">// black, white, red are scoped to Color</span>
<span class="k">auto</span> <span class="n">white</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// fine, no other `white` in scope</span>
<span class="n">Color</span> <span class="n">c</span> <span class="o">=</span> <span class="n">white</span><span class="p">;</span> <span class="c1">// err! no enum named `white` is in this scope</span>
<span class="n">Color</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">white</span><span class="p">;</span> <span class="c1">//fine</span>
<span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">white</span><span class="p">;</span> <span class="c1">// fine</span>
</code></pre></div></div>

<p>Advs:</p>

<ul>
  <li>enumerators are mush more strongly typed. Enumerators for unscoped enums implicitly convert to integral types (and, from there, to floating-point types)</li>
  <li>their names may be forward-declared(Ex: <code class="language-plaintext highlighter-rouge">enum class Color;</code>), and changing the definition of the enum class(Ex: add a new child) requires no recompilation.</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">Status</span><span class="p">;</span> <span class="c1">//underlying type is int</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">Status</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">;</span> <span class="c1">// underlying type is std::uint32_t(from &lt;cstdint)</span>
</code></pre></div></div>

<p>Unscoped enums:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Color</span> <span class="p">{</span> <span class="n">black</span><span class="p">,</span> <span class="n">white</span><span class="p">,</span> <span class="n">red</span> <span class="p">};</span> <span class="c1">// black, white, red are in same scope as Color</span>
<span class="k">auto</span> <span class="n">white</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// err! whilte already decleared in this scope</span>
</code></pre></div></div>

  
</article>


<hr class="dingbat related" />




  
     


  <aside class="about related mt4 mb4" role="complementary">
    
    

<div class="author mt4">
  

  
    
  

  

  
  <img
    src="https://media.licdn.com/dms/image/C5103AQHI6-B3NChVsQ/profile-displayphoto-shrink_800_800/0/1517243228094?e=1703721600&v=beta&t=ahUUQYJQXUkIEcPcK47lKJy8iCIPBNSzQr0V55Z2pVk
"
    class="avatar"
    alt="<firstname> <lastname>"
    srcset="https://media.licdn.com/dms/image/C5103AQHI6-B3NChVsQ/profile-displayphoto-shrink_800_800/0/1517243228094?e=1703721600&v=beta&t=ahUUQYJQXUkIEcPcK47lKJy8iCIPBNSzQr0V55Z2pVk
 1x,https://media.licdn.com/dms/image/C5103AQHI6-B3NChVsQ/profile-displayphoto-shrink_800_800/0/1517243228094?e=1703721600&v=beta&t=ahUUQYJQXUkIEcPcK47lKJy8iCIPBNSzQr0V55Z2pVk
 2x"
    
    
  />


  

  
  
  <h2  class="page-title hr">
    About
  </h2>

  <p>I’m passinated about sharing my deep understanding on classic &amp; latest computer science and AI technologies.</p>


  <div class="sidebar-social">
    <span class="sr-only">Social:</span>
<ul>
  

  

  
    













<li>
  <a href="https://twitter.com/<username>" title="Twitter" class="no-mark-external">
    <span class="icon-twitter"></span>
    <span class="sr-only">Twitter</span>
  </a>
</li>

  
    













<li>
  <a href="https://github.com/<username>" title="GitHub" class="no-mark-external">
    <span class="icon-github"></span>
    <span class="sr-only">GitHub</span>
  </a>
</li>

  
    













<li>
  <a href="mailto:<mail@domain.tld>" title="Email" class="no-mark-external">
    <span class="icon-mail"></span>
    <span class="sr-only">Email</span>
  </a>
</li>

  
    













<li>
  <a href="https://<url>/feed.xml" title="RSS" class="no-mark-external">
    <span class="icon-rss2"></span>
    <span class="sr-only">RSS</span>
  </a>
</li>

  
</ul>

  </div>
</div>

  </aside>


  

  
  

  
    




<aside class="related mb4" role="complementary">
  <h2 class="hr">Related Posts</h2>

  <ul class="related-posts">
    
      


<li>
  <a href="/myBlog/2023/10/21/let-the-wind-goes/" class="h4 flip-title">
    <span>7年北美回议录</span>
  </a>
  <time class="heading faded fine" datetime="2023-10-21T00:00:00-04:00">21 Oct 2023</time>
</li>

    
  </ul>
</aside>


  


    


    <footer role="contentinfo">
  <hr/>
  
  <p><small class="copyright">© 20XX. Open _config.yml to edit this text.</small></p>
  
  <p><small>Powered by <a class="external" href="https://qwtel.com/hydejack/">Hydejack</a> v<span id="_version">7.2.0</span></small></p>
  <hr class="sr-only"/>
</footer>

  </main>
  <hy-drawer>
  <header id="_sidebar" class="sidebar" role="banner">
    
    <div class="sidebar-bg sidebar-overlay" style="background-color:#4fb1ba;background-image:url(/myBlog/assets/img/sidebar-bg.jpg
)"></div>
    <script type="text/javascript" src="//ra.revolvermaps.com/0/0/8.js?i=0103zcjc3f9&amp;m=0&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33" async="async"></script>
    <div class="sidebar-sticky">
      <div class="sidebar-about">
        <h2 class="h1"><a href="/myBlog/">blog</a></h2>
        
        
          <p class="">
            A Jekyll theme with JavaScript powers. Open <code class="language-plaintext highlighter-rouge">_config.yml</code> to edit this text.

          </p>
        
      </div>

      <nav class="sidebar-nav heading" role="navigation">
        <span class="sr-only">Navigation:</span>
<ul>
  
  
  
  
    
      <li>
        <a
          id="_navigation"
          href="/myBlog/tag/hyde/"
          class="sidebar-nav-item"
          
          >
          Hyde
        </a>
      </li>
    
  
    
      <li>
        <a
          
          href="/myBlog/tag/hydejack/"
          class="sidebar-nav-item"
          
          >
          Hydejack
        </a>
      </li>
    
  
    
      <li>
        <a
          
          href="/myBlog/about/"
          class="sidebar-nav-item"
          
          >
          About
        </a>
      </li>
    
  
    
      <li>
        <a
          
          href="/myBlog/docs/7.2.0/"
          class="sidebar-nav-item"
          
          >
          Documentation
        </a>
      </li>
    
  
</ul>

      </nav>

      

      <div class="sidebar-social">
        <span class="sr-only">Social:</span>
<ul>
  

  

  
    













<li>
  <a href="https://twitter.com/<username>" title="Twitter" class="no-mark-external">
    <span class="icon-twitter"></span>
    <span class="sr-only">Twitter</span>
  </a>
</li>

  
    













<li>
  <a href="https://github.com/<username>" title="GitHub" class="no-mark-external">
    <span class="icon-github"></span>
    <span class="sr-only">GitHub</span>
  </a>
</li>

  
    













<li>
  <a href="mailto:<mail@domain.tld>" title="Email" class="no-mark-external">
    <span class="icon-mail"></span>
    <span class="sr-only">Email</span>
  </a>
</li>

  
    













<li>
  <a href="https://<url>/feed.xml" title="RSS" class="no-mark-external">
    <span class="icon-rss2"></span>
    <span class="sr-only">RSS</span>
  </a>
</li>

  
</ul>

      </div>
    </div>
  </header>
</hy-drawer>

</hy-push-state>


  

  <!--[if gt IE 9]><!---->
  
  <script>loadJSDeferred('/myBlog/assets/js/hydejack-7.2.0.js');</script>

  

  <!--<![endif]-->



  
<hr class="sr-only"/>
<h2 class="sr-only">Templates (for web app):</h2>

<template id="_animation-template">
  <div class="animation-main fixed-top">
    <div class="content">
      <div class="page"></div>
    </div>
  </div>
</template>

<template id="_loading-template">
  <div class="loading">
    <span class="sr-only">Loading…</span>
    <span class="icon-cog"></span>
  </div>
</template>

<template id="_error-template">
  <div class="page">
    <h1 class="page-title">Error</h1>
    
    
    <p class="lead">
      Sorry, an error occurred while loading <a class="this-link" href=""></a>.

    </p>
  </div>
</template>

<template id="_back-template">
  <a id="_back" class="back nav-btn no-hover">
    <span class="sr-only">Back</span>
    <span class="icon-arrow-left2"></span>
  </a>
</template>

</body>
</html>
